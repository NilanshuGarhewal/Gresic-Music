"use client";

import { useEffect, useRef } from "react";

// Interface for mouse position objects
interface MousePosition {
  x: number;
  y: number;
}

// Interface for a single trail image item in the trailRef array
interface TrailItem {
  element: HTMLDivElement;
  maskLayers: HTMLDivElement[];
  imageLayers: HTMLDivElement[];
  removeTime: number;
}

const TrailContainer = () => {
  // Refs to store DOM elements and state that persists across renders without causing re-renders
  const trailContainerRef = useRef<HTMLDivElement | null>(null);
  // `number | null` is used because `requestAnimationFrame` returns a number, and `null` is the initial value.
  const animationStateRef = useRef<number | null>(null);
  const trailRef = useRef<TrailItem[]>([]);
  const currentImageIndexRef = useRef<number>(0);
  const mousePosRef = useRef<MousePosition>({ x: 0, y: 0 });
  const lastMousePosRef = useRef<MousePosition>({ x: 0, y: 0 });
  const interpolatedMousePosRef = useRef<MousePosition>({ x: 0, y: 0 });
  const isDesktopRef = useRef<boolean>(false);
  const isMobileRef = useRef<boolean>(false);
  const isHoveringRef = useRef<boolean>(false);
  const idleTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  // Configuration for the animation and image effects
  const config = {
    imageLifespan: 1000,
    mouseThreshold: 150,
    inDuration: 750,
    outDuration: 1000,
    staggerIn: 100,
    staggerOut: 25,
    slideDuration: 1000,
    slideEasing: "cubic-bezier(0.25, 0.46, 0.45, 0.94)",
    easing: "cubic-bezier(0.87, 0, 0.13, 1)",
    randomImageInterval: { min: 500, max: 1500 },
  };

  // Utility functions for mathematical calculations with explicit types
  const MathUtils = {
    lerp: (a: number, b: number, n: number): number => (1 - n) * a + n * b,
    distance: (x1: number, y1: number, x2: number, y2: number): number =>
      Math.hypot(x2 - x1, y2 - y1),
    random: (min: number, max: number): number =>
      Math.random() * (max - min) + min,
  };

  // Total number of images in the trail
  const trailImageCount: number = 10;
  // Array of image paths, dynamically generated with a string array type
  const images: string[] = Array.from(
    { length: trailImageCount },
    (_, i) => `/assets/trailImages/img${i + 1}.avif` // Using unsplash for random images
  );

  // Calculates the distance between the current and last mouse positions
  const getMouseDistance = (): number => {
    return MathUtils.distance(
      mousePosRef.current.x,
      mousePosRef.current.y,
      lastMousePosRef.current.x,
      lastMousePosRef.current.y
    );
  };

  // Generic function to create and animate a new image element
  const spawnImage = (
    targetX: number,
    targetY: number,
    slideFrom?: MousePosition
  ) => {
    const trailContainer = trailContainerRef.current;
    if (!trailContainer) return;

    const imgContainer = document.createElement("div");
    imgContainer.classList.add("trail-img");

    const imgSrc: string = images[currentImageIndexRef.current];
    currentImageIndexRef.current =
      (currentImageIndexRef.current + 1) % trailImageCount;

    const rect = trailContainer.getBoundingClientRect();

    const finalX = targetX - rect.left - 87.5;
    const finalY = targetY - rect.top - 87.5;
    
    const startX = slideFrom
      ? slideFrom.x - rect.left - 87.5
      : finalX;
    const startY = slideFrom
      ? slideFrom.y - rect.top - 87.5
      : finalY;


    imgContainer.style.left = `${startX}px`;
    imgContainer.style.top = `${startY}px`;
    if (slideFrom) {
        imgContainer.style.transition = `left ${config.slideDuration}ms ${config.slideEasing}, top ${config.slideDuration}ms ${config.slideEasing}`;
    }


    const maskLayers: HTMLDivElement[] = [];
    const imageLayers: HTMLDivElement[] = [];

    for (let i = 0; i < 10; i++) {
      const layer = document.createElement("div");
      layer.classList.add("mask-layer");

      const imageLayer = document.createElement("div");
      imageLayer.classList.add("image-layer");
      imageLayer.style.backgroundImage = `url(${imgSrc})`;

      const startYMask: number = i * 10;
      const endYMask: number = (i + 1) * 10;

      layer.style.clipPath = `polygon(50% ${startYMask}%, 50% ${startYMask}%, 50% ${endYMask}%, 50% ${endYMask}%)`;
      layer.style.transition = `clip-path ${config.inDuration}ms ${config.easing}`;
      layer.style.transform = "translateZ(0)";
      layer.style.backfaceVisibility = "hidden";

      layer.appendChild(imageLayer);
      imgContainer.appendChild(layer);
      maskLayers.push(layer);
      imageLayers.push(imageLayer);
    }

    trailContainer.appendChild(imgContainer);

    requestAnimationFrame(() => {
        imgContainer.style.left = `${finalX}px`;
        imgContainer.style.top = `${finalY}px`;
      
      maskLayers.forEach((layer, i) => {
        const startYMask: number = i * 10;
        const endYMask: number = (i + 1) * 10;
        const distanceFromMiddle: number = Math.abs(i - 4.5);
        const delay: number = distanceFromMiddle * config.staggerIn;

        setTimeout(() => {
          layer.style.clipPath = `polygon(0% ${startYMask}%, 100% ${startYMask}%, 100% ${endYMask}%, 0% ${endYMask}%)`;
        }, delay);
      });
    });

    trailRef.current.push({
      element: imgContainer,
      maskLayers: maskLayers,
      imageLayers: imageLayers,
      removeTime: Date.now() + config.imageLifespan,
    });
  };

  // Creates an image based on mouse movement
  const createTrailImage = (): void => {
    spawnImage(mousePosRef.current.x, mousePosRef.current.y, interpolatedMousePosRef.current);
  };
  
  // Creates an image at a random location within the container
  const createRandomImage = (): void => {
      const trailContainer = trailContainerRef.current;
      if (!trailContainer) return;
      const rect = trailContainer.getBoundingClientRect();
      const randomX = MathUtils.random(rect.left, rect.right);
      const randomY = MathUtils.random(rect.top, rect.bottom);
      spawnImage(randomX, randomY);
  };
  
  // Schedules the next random image to appear
  const scheduleNextRandomImage = (): void => {
      if(idleTimeoutRef.current) clearTimeout(idleTimeoutRef.current);

      idleTimeoutRef.current = setTimeout(() => {
        if (isMobileRef.current || (!isHoveringRef.current && isDesktopRef.current)) {
            createRandomImage();
            scheduleNextRandomImage();
        }
      }, MathUtils.random(config.randomImageInterval.min, config.randomImageInterval.max));
  };


  // Removes old images from the trail
  const removeOldImages = (): void => {
    const now: number = Date.now();
    if (trailRef.current.length === 0) return;

    const oldestImage: TrailItem = trailRef.current[0];
    if (now > oldestImage.removeTime) {
      const imgToRemove: TrailItem = trailRef.current.shift()!;

      imgToRemove.maskLayers.forEach((layer, i) => {
        const startYMask: number = i * 10;
        const endYMask: number = (i + 1) * 10;
        const distanceFromEdge: number = 4.5 - Math.abs(i - 4.5);
        const delay: number = distanceFromEdge * config.staggerOut;

        layer.style.transition = `clip-path ${config.outDuration}ms ${config.easing}`;
        setTimeout(() => {
          layer.style.clipPath = `polygon(50% ${startYMask}%, 50% ${startYMask}%, 50% ${endYMask}%, 50% ${endYMask}%)`;
        }, delay);
      });

      const totalAnimationDuration =
        config.outDuration + 4.5 * config.staggerOut + 100;
      setTimeout(() => {
        if (imgToRemove.element.parentNode) {
          imgToRemove.element.parentNode.removeChild(imgToRemove.element);
        }
      }, totalAnimationDuration);
    }
  };

  // The main render loop for the animation
  const render = (): void => {
    // Only run mouse-related logic on desktop
    if (isDesktopRef.current) {
        const distance: number = getMouseDistance();

        interpolatedMousePosRef.current.x = MathUtils.lerp(
        interpolatedMousePosRef.current.x || mousePosRef.current.x,
        mousePosRef.current.x,
        0.1
        );
        interpolatedMousePosRef.current.y = MathUtils.lerp(
        interpolatedMousePosRef.current.y || mousePosRef.current.y,
        mousePosRef.current.y,
        0.1
        );

        if (
        isHoveringRef.current &&
        distance > config.mouseThreshold
        ) {
        createTrailImage();
        lastMousePosRef.current = { ...mousePosRef.current };
        }
    }

    removeOldImages();
    
    // Keep the loop running if an animation is active or images need to be removed.
    const isAnimationActive = isDesktopRef.current || isMobileRef.current;
    if (isAnimationActive || trailRef.current.length > 0) {
        animationStateRef.current = requestAnimationFrame(render);
    } else {
        animationStateRef.current = null;
    }
  };
  
  // Stops the animation and removes all trail images
  const stopAnimation = (): void => {
    if (animationStateRef.current) {
      cancelAnimationFrame(animationStateRef.current);
      animationStateRef.current = null;
    }
    if(idleTimeoutRef.current) clearTimeout(idleTimeoutRef.current);

    trailRef.current.forEach((item) => {
      if (item.element.parentNode) {
        item.element.parentNode.removeChild(item.element);
      }
    });
    trailRef.current.length = 0;
  };

  // Main effect hook for setting up and tearing down listeners
  useEffect(() => {
    const trailContainer = trailContainerRef.current;
    if (!trailContainer) return;
    
    // Create a global stylesheet for the animations and styles
    const style = document.createElement('style');
    style.innerHTML = `
        .trail-container {
            width: 100%;
            height: 100vh;
            overflow: hidden;
            position: relative;
            background-color: #f0f0f0;
        }
        .trail-img {
            position: absolute;
            width: 175px;
            height: 175px;
            pointer-events: none;
            transform: translate3d(0, 0, 0);
        }
        .mask-layer {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        .image-layer {
            position: absolute;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
        }
    `;
    document.head.appendChild(style);
    
    let mouseMoveCleanup: (() => void) | null = null;
    let hoverCleanup: (() => void) | null = null;
    
    const startLoops = () => {
        if (!animationStateRef.current) {
            animationStateRef.current = requestAnimationFrame(render);
        }
        scheduleNextRandomImage();
    }

    const setupForSize = () => {
        if (mouseMoveCleanup) mouseMoveCleanup();
        if (hoverCleanup) hoverCleanup();
        stopAnimation();

        const width = window.innerWidth;
        isDesktopRef.current = width > 1000;
        isMobileRef.current = width < 500;

        if (isDesktopRef.current) {
            const handleMouseMove = (e: MouseEvent): void => {
              mousePosRef.current = { x: e.clientX, y: e.clientY };
            };
            document.addEventListener("mousemove", handleMouseMove);
            mouseMoveCleanup = () => document.removeEventListener("mousemove", handleMouseMove);

            const handleMouseEnter = () => {
                isHoveringRef.current = true;
                if(idleTimeoutRef.current) clearTimeout(idleTimeoutRef.current);
                lastMousePosRef.current = { ...mousePosRef.current };
            };
            const handleMouseLeave = () => {
                isHoveringRef.current = false;
                scheduleNextRandomImage();
            };
            trailContainer.addEventListener("mouseenter", handleMouseEnter);
            trailContainer.addEventListener("mouseleave", handleMouseLeave);
            hoverCleanup = () => {
                trailContainer.removeEventListener("mouseenter", handleMouseEnter);
                trailContainer.removeEventListener("mouseleave", handleMouseLeave);
            };
            startLoops();
        } else if (isMobileRef.current) {
            startLoops();
        }
    };

    setupForSize();
    window.addEventListener("resize", setupForSize);

    return () => {
        stopAnimation();
        if (mouseMoveCleanup) mouseMoveCleanup();
        if (hoverCleanup) hoverCleanup();
        window.removeEventListener("resize", setupForSize);
        document.head.removeChild(style);
    };
  }, []);

  // JSX for the component
  return (
    <div className="trail-container" ref={trailContainerRef}>
    </div>
  );
};

export default TrailContainer;

